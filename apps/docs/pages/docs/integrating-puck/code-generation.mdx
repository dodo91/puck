import { Callout } from "nextra/components";

# Code generation workflows

Puck stores editor output as structured JSON. Because the structure is deterministic (see the [data model](/docs/api-reference/data-model/data)), you can turn published data back into source code, static markup, or any other artifact that suits your workflow.

This document shows how to capture data from the editor and transform it into a React moduleâ€”similar to the approach taken by [ui-builder](https://github.com/olliethedev/ui-builder).

## Capture editor data via `onPublish`

[`<Puck>`](/docs/api-reference/components/puck) surfaces an [`onPublish(data)`](/docs/api-reference/components/puck#onpublishdata) prop. Whenever an editor publishes their changes, the callback receives the full `data` payload.

```tsx copy showLineNumbers
import type { Config, Data } from "@measured/puck";
import { Puck } from "@measured/puck";

const config: Config = { /* ...component definitions... */ };
const initialData: Data = { /* ...seed content... */ };

export function Editor() {
  return (
    <Puck
      config={config}
      data={initialData}
      onPublish={async (data) => {
        const source = generateReactModule({ data, config });
        await saveToRepository(source);
      }}
    />
  );
}
```

Because you control the `onPublish` callback, you can decide whether generated code is committed to git, stored alongside other CMS entries, or written to disk for use in CI.

## Generate a React module from Puck data

The snippet below converts a `data` payload into a React component tree. It mirrors how codegen tools such as [ui-builder](https://github.com/olliethedev/ui-builder) emit React components.

```tsx copy showLineNumbers
import type { Config, Data, Slot } from "@measured/puck";

type Components = {
  Grid: { content: Slot<Components> };
  AntdCard: { title: string; body: string };
};

type GenerateArgs = {
  data: Data<Components>;
  config: Config<Components>;
};

const componentImports: Record<keyof Components, string> = {
  Grid: "@/components/Grid",
  AntdCard: "@/components/AntdCard",
};

export function generateReactModule({ data, config }: GenerateArgs) {
  const usedImports = new Set<string>();

  const body = data.content
    .map((item) => renderNode(item, { usedImports, config, depth: 4 }))
    .join("\n");

  const importLines = Array.from(usedImports).map((component) => {
    return `import ${component} from "${componentImports[component as keyof Components]}";`;
  });

  return [
    "import React from \"react\";",
    ...importLines,
    "",
    "export default function GeneratedPage() {",
    "  return (",
    body,
    "  );",
    "}",
    "",
  ].join("\n");
}

type RenderNodeArgs = {
  usedImports: Set<string>;
  config: Config<Components>;
  depth: number;
};

type Node = Data<Components>["content"][number];

function renderNode(node: Node, ctx: RenderNodeArgs): string {
  const componentName = node.type;
  if (!ctx.config.components[componentName]) {
    throw new Error(`Unknown component: ${componentName}`);
  }

  ctx.usedImports.add(componentName);

  const props = { ...node.props };
  delete props.id;

  const children = Object.entries(props)
    .filter(([, value]) => Array.isArray(value) && value.every((child) => "type" in child))
    .map(([key, value]) => {
      const childNodes = value as Node[];
      delete props[key];
      const childBody = childNodes
        .map((child) => renderNode(child, { ...ctx, depth: ctx.depth + 2 }))
        .join("\n");

      return `\n${childBody}\n${" ".repeat(ctx.depth)}`;
    })
    .join("");

  const propString = Object.entries(props)
    .map(([key, value]) => ` ${key}={${JSON.stringify(value)}}`)
    .join("");

  const indent = " ".repeat(ctx.depth);
  const openingTag = `${indent}<${componentName}${propString}>`;
  const closingTag = `${indent}</${componentName}>`;

  return children ? `${openingTag}${children}${closingTag}` : `${openingTag}${closingTag}`;
}
```

A few important details:

- `componentImports` maps Puck component names to real file paths. Swap these out for the paths that match your design system.
- Slot fields are persisted as arrays of nested components. The generator above treats any prop that looks like an array of Puck components as children and recurses into them.
- You can embed richer logic (for example, condensing text nodes into template literals or expanding data bindings) by inspecting the component config inside `renderNode`.

<Callout>
`ui-builder` already demonstrates an end-to-end code generation workflow that targets Puck. Use it as a blueprint if you need inspiration for repo layouts, CLIs, or dev-server integration.
</Callout>

## Save artifacts wherever you need them

`generateReactModule` only returns a string. You can write it to the filesystem, create a git commit, or POST it to another service. Because the generator is pure, it can also run during CI to prevent drift between the saved JSON payload and the generated files.

```ts copy showLineNumbers
import { writeFile } from "node:fs/promises";

async function saveToRepository(source: string) {
  await writeFile("./src/pages/generated-page.tsx", source, "utf8");
}
```

By combining `onPublish`, the strongly typed Puck config, and a small generator, you can export code tailored to your stack while still giving editors a visual builder.
